<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Paint</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0d1117;
      color: #c9d1d9;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .toolbar {
      background: #161b22;
      border-bottom: 1px solid #30363d;
      padding: 8px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    
    .tool-group {
      display: flex;
      align-items: center;
      gap: 4px;
      padding-right: 12px;
      border-right: 1px solid #30363d;
    }
    
    .tool-group:last-child {
      border-right: none;
    }
    
    .tool-btn {
      background: #21262d;
      border: 1px solid #30363d;
      color: #8b949e;
      width: 36px;
      height: 36px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }
    
    .tool-btn:hover {
      background: #30363d;
      color: #c9d1d9;
    }
    
    .tool-btn.active {
      background: #58a6ff;
      color: #0d1117;
      border-color: #58a6ff;
    }
    
    .color-picker {
      width: 36px;
      height: 36px;
      border: 2px solid #30363d;
      border-radius: 6px;
      cursor: pointer;
      padding: 0;
      background: none;
    }
    
    .color-picker::-webkit-color-swatch-wrapper {
      padding: 2px;
    }
    
    .color-picker::-webkit-color-swatch {
      border: none;
      border-radius: 3px;
    }
    
    .size-slider {
      width: 80px;
      height: 6px;
      -webkit-appearance: none;
      background: #30363d;
      border-radius: 3px;
      outline: none;
    }
    
    .size-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #58a6ff;
      border-radius: 50%;
      cursor: pointer;
    }
    
    .size-label {
      font-size: 12px;
      color: #8b949e;
      min-width: 30px;
    }
    
    .canvas-container {
      flex: 1;
      overflow: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    
    canvas {
      background: white;
      border: 1px solid #30363d;
      cursor: crosshair;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .color-palette {
      display: flex;
      gap: 4px;
    }
    
    .palette-color {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: transform 0.1s;
    }
    
    .palette-color:hover {
      transform: scale(1.1);
    }
    
    .palette-color.active {
      border-color: #58a6ff;
    }
    
    .status-bar {
      background: #161b22;
      border-top: 1px solid #30363d;
      padding: 4px 12px;
      font-size: 11px;
      color: #8b949e;
      display: flex;
      justify-content: space-between;
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <div class="tool-group">
      <button class="tool-btn active" data-tool="brush" title="Brush">üñåÔ∏è</button>
      <button class="tool-btn" data-tool="eraser" title="Eraser">üßπ</button>
      <button class="tool-btn" data-tool="fill" title="Fill">ü™£</button>
      <button class="tool-btn" data-tool="line" title="Line">üìè</button>
      <button class="tool-btn" data-tool="rect" title="Rectangle">‚¨ú</button>
      <button class="tool-btn" data-tool="circle" title="Circle">‚≠ï</button>
    </div>
    
    <div class="tool-group">
      <input type="color" class="color-picker" id="color" value="#000000" title="Color" />
      <div class="color-palette" id="palette"></div>
    </div>
    
    <div class="tool-group">
      <span class="size-label" id="size-label">5px</span>
      <input type="range" class="size-slider" id="size" min="1" max="50" value="5" />
    </div>
    
    <div class="tool-group">
      <button class="tool-btn" id="undo" title="Undo">‚Ü©Ô∏è</button>
      <button class="tool-btn" id="redo" title="Redo">‚Ü™Ô∏è</button>
      <button class="tool-btn" id="clear" title="Clear">üóëÔ∏è</button>
      <button class="tool-btn" id="save" title="Save">üíæ</button>
    </div>
  </div>
  
  <div class="canvas-container">
    <canvas id="canvas" width="800" height="500"></canvas>
  </div>
  
  <div class="status-bar">
    <span id="coords">0, 0</span>
    <span id="canvas-size">800 √ó 500</span>
  </div>
  
  <script src="https://clawdos.space/sdk/clawd-miniapp-sdk.js"></script>
  <script>
    if (window.clawd) {
      clawd.ready();
      clawd.setTitle('Paint');
    }
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const colorPicker = document.getElementById('color');
    const sizeSlider = document.getElementById('size');
    const sizeLabel = document.getElementById('size-label');
    const coords = document.getElementById('coords');
    const palette = document.getElementById('palette');
    
    // State
    let currentTool = 'brush';
    let currentColor = '#000000';
    let currentSize = 5;
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let startX = 0;
    let startY = 0;
    
    // History for undo/redo
    const history = [];
    let historyIndex = -1;
    const maxHistory = 50;
    
    // Color palette
    const colors = [
      '#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff',
      '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#8800ff'
    ];
    
    colors.forEach(color => {
      const el = document.createElement('div');
      el.className = 'palette-color';
      el.style.background = color;
      el.onclick = () => {
        currentColor = color;
        colorPicker.value = color;
        document.querySelectorAll('.palette-color').forEach(p => p.classList.remove('active'));
        el.classList.add('active');
      };
      palette.appendChild(el);
    });
    
    // Save initial state
    saveState();
    
    function saveState() {
      // Remove future states if we're in the middle of history
      if (historyIndex < history.length - 1) {
        history.splice(historyIndex + 1);
      }
      
      // Save current state
      history.push(canvas.toDataURL());
      historyIndex++;
      
      // Limit history size
      if (history.length > maxHistory) {
        history.shift();
        historyIndex--;
      }
    }
    
    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        const img = new Image();
        img.onload = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
        };
        img.src = history[historyIndex];
      }
    }
    
    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        const img = new Image();
        img.onload = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
        };
        img.src = history[historyIndex];
      }
    }
    
    // Tool buttons
    document.querySelectorAll('[data-tool]').forEach(btn => {
      btn.onclick = () => {
        document.querySelectorAll('[data-tool]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTool = btn.dataset.tool;
      };
    });
    
    colorPicker.oninput = (e) => {
      currentColor = e.target.value;
      document.querySelectorAll('.palette-color').forEach(p => p.classList.remove('active'));
    };
    
    sizeSlider.oninput = (e) => {
      currentSize = parseInt(e.target.value);
      sizeLabel.textContent = currentSize + 'px';
    };
    
    document.getElementById('undo').onclick = undo;
    document.getElementById('redo').onclick = redo;
    
    document.getElementById('clear').onclick = () => {
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      saveState();
    };
    
    document.getElementById('save').onclick = () => {
      const link = document.createElement('a');
      link.download = 'drawing.png';
      link.href = canvas.toDataURL();
      link.click();
      
      if (window.clawd) {
        clawd.showToast('Image saved!');
      }
    };
    
    // Drawing functions
    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      if (e.touches) {
        return {
          x: (e.touches[0].clientX - rect.left) * scaleX,
          y: (e.touches[0].clientY - rect.top) * scaleY
        };
      }
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
      };
    }
    
    function startDraw(e) {
      e.preventDefault();
      isDrawing = true;
      const pos = getPos(e);
      lastX = pos.x;
      lastY = pos.y;
      startX = pos.x;
      startY = pos.y;
      
      if (currentTool === 'brush' || currentTool === 'eraser') {
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
      } else if (currentTool === 'fill') {
        floodFill(Math.floor(pos.x), Math.floor(pos.y), currentColor);
        saveState();
      }
    }
    
    function draw(e) {
      e.preventDefault();
      const pos = getPos(e);
      coords.textContent = `${Math.round(pos.x)}, ${Math.round(pos.y)}`;
      
      if (!isDrawing) return;
      
      if (currentTool === 'brush') {
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
      } else if (currentTool === 'eraser') {
        ctx.strokeStyle = 'white';
        ctx.lineWidth = currentSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
      }
      
      lastX = pos.x;
      lastY = pos.y;
    }
    
    function endDraw(e) {
      if (!isDrawing) return;
      
      const pos = e ? getPos(e) : { x: lastX, y: lastY };
      
      if (currentTool === 'line') {
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentSize;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
      } else if (currentTool === 'rect') {
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentSize;
        ctx.strokeRect(startX, startY, pos.x - startX, pos.y - startY);
      } else if (currentTool === 'circle') {
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = currentSize;
        const rx = Math.abs(pos.x - startX) / 2;
        const ry = Math.abs(pos.y - startY) / 2;
        const cx = startX + (pos.x - startX) / 2;
        const cy = startY + (pos.y - startY) / 2;
        ctx.beginPath();
        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      isDrawing = false;
      
      if (currentTool !== 'fill') {
        saveState();
      }
    }
    
    // Flood fill algorithm
    function floodFill(x, y, fillColor) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      const targetColor = getPixel(data, x, y);
      const fill = hexToRgb(fillColor);
      
      if (colorsMatch(targetColor, fill)) return;
      
      const stack = [[x, y]];
      const visited = new Set();
      
      while (stack.length > 0) {
        const [cx, cy] = stack.pop();
        const key = `${cx},${cy}`;
        
        if (visited.has(key)) continue;
        if (cx < 0 || cx >= canvas.width || cy < 0 || cy >= canvas.height) continue;
        
        const current = getPixel(data, cx, cy);
        if (!colorsMatch(current, targetColor)) continue;
        
        visited.add(key);
        setPixel(data, cx, cy, fill);
        
        stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
      }
      
      ctx.putImageData(imageData, 0, 0);
    }
    
    function getPixel(data, x, y) {
      const i = (y * canvas.width + x) * 4;
      return { r: data[i], g: data[i + 1], b: data[i + 2], a: data[i + 3] };
    }
    
    function setPixel(data, x, y, color) {
      const i = (y * canvas.width + x) * 4;
      data[i] = color.r;
      data[i + 1] = color.g;
      data[i + 2] = color.b;
      data[i + 3] = 255;
    }
    
    function colorsMatch(a, b) {
      return Math.abs(a.r - b.r) < 10 && Math.abs(a.g - b.g) < 10 && Math.abs(a.b - b.b) < 10;
    }
    
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 0, g: 0, b: 0 };
    }
    
    // Event listeners
    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('mouseleave', endDraw);
    
    canvas.addEventListener('touchstart', startDraw);
    canvas.addEventListener('touchmove', draw);
    canvas.addEventListener('touchend', endDraw);
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        if (e.shiftKey) {
          redo();
        } else {
          undo();
        }
      } else if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        document.getElementById('save').click();
      }
    });
    
    // Initialize white canvas
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  </script>
</body>
</html>
